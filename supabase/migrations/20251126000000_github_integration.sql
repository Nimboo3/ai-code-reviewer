-- =============================================================================
-- Migration: GitHub Integration & PR Review System
-- 
-- This migration adds:
-- 1. github_connections - Store GitHub OAuth tokens and user info
-- 2. github_repositories - Connected repositories for monitoring
-- 3. pr_reviews - Cached AI reviews for pull requests
-- 4. Proper RLS policies and indexes for performance
--
-- Optimized for Gemini Free Tier:
-- - Caching reviews to avoid re-analyzing same commits
-- - Per-user rate limiting (10 reviews/day)
-- - File-level caching by content hash
--
-- To run this migration:
-- 1. Open Supabase SQL Editor
-- 2. Paste this entire file
-- 3. Execute
-- =============================================================================

-- =============================================================================
-- 1. GitHub Connections Table
-- Stores OAuth tokens and user info for GitHub integration
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.github_connections (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- User reference
    user_id UUID NOT NULL REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE,
    
    -- GitHub user info
    github_user_id BIGINT NOT NULL,
    github_username TEXT NOT NULL,
    github_avatar_url TEXT,
    github_email TEXT,
    
    -- OAuth tokens (In production, consider encrypting these)
    access_token TEXT NOT NULL,
    token_type TEXT DEFAULT 'bearer',
    scope TEXT,
    
    -- Metadata
    connected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT unique_user_github UNIQUE (user_id),
    CONSTRAINT unique_github_user UNIQUE (github_user_id)
);

-- Enable RLS
ALTER TABLE public.github_connections ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if exists and create new one
DO $$
BEGIN
    DROP POLICY IF EXISTS "Users can only access their own GitHub connections" ON public.github_connections;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Users can only access their own GitHub connections"
ON public.github_connections
FOR ALL
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Grants
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.github_connections TO authenticated, service_role;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_github_connections_user_id ON public.github_connections(user_id);
CREATE INDEX IF NOT EXISTS idx_github_connections_github_user_id ON public.github_connections(github_user_id);

-- =============================================================================
-- 2. GitHub Repositories Table
-- Stores connected repositories for monitoring
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.github_repositories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- User reference
    user_id UUID NOT NULL REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE,
    
    -- Repository info
    github_repo_id BIGINT NOT NULL,
    repo_name TEXT NOT NULL,
    repo_full_name TEXT NOT NULL, -- e.g., "owner/repo"
    default_branch TEXT DEFAULT 'main',
    language TEXT,
    is_private BOOLEAN DEFAULT FALSE,
    owner_login TEXT NOT NULL,
    
    -- Settings
    auto_review_enabled BOOLEAN DEFAULT TRUE,
    webhook_id BIGINT, -- GitHub webhook ID if installed
    webhook_secret TEXT, -- Webhook secret for verification
    
    -- Metadata
    last_synced_at TIMESTAMPTZ,
    architecture_score INTEGER, -- 0-100
    tech_debt_score INTEGER, -- 0-100
    security_score INTEGER, -- 0-100
    
    -- Constraints
    CONSTRAINT unique_user_repo UNIQUE (user_id, github_repo_id)
);

-- Enable RLS
ALTER TABLE public.github_repositories ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if exists and create new one
DO $$
BEGIN
    DROP POLICY IF EXISTS "Users can only access their own repositories" ON public.github_repositories;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Users can only access their own repositories"
ON public.github_repositories
FOR ALL
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Grants
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.github_repositories TO authenticated, service_role;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_github_repositories_user_id ON public.github_repositories(user_id);
CREATE INDEX IF NOT EXISTS idx_github_repositories_github_repo_id ON public.github_repositories(github_repo_id);
CREATE INDEX IF NOT EXISTS idx_github_repositories_full_name ON public.github_repositories(repo_full_name);

-- =============================================================================
-- 3. PR Reviews Table
-- Stores AI-generated reviews for pull requests (caching layer)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.pr_reviews (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- User reference
    user_id UUID NOT NULL REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE,
    
    -- PR identification
    repo_full_name TEXT NOT NULL, -- e.g., "owner/repo"
    pr_number INTEGER NOT NULL,
    pr_title TEXT,
    head_sha TEXT NOT NULL, -- Git commit SHA (used for cache invalidation)
    base_sha TEXT,
    
    -- Review results
    overall_score INTEGER, -- 0-100
    grade TEXT, -- A+, A, B, C, D, F
    risk_level TEXT, -- low, medium, high, critical
    total_issues INTEGER DEFAULT 0,
    critical_issues INTEGER DEFAULT 0,
    high_issues INTEGER DEFAULT 0,
    medium_issues INTEGER DEFAULT 0,
    low_issues INTEGER DEFAULT 0,
    
    -- Full review data (JSON)
    review_data JSONB,
    
    -- Metadata
    model TEXT DEFAULT 'gemini-2.0-flash-exp',
    tokens_used INTEGER,
    review_duration_ms INTEGER,
    
    -- Constraints - Cache key: repo + pr_number + head_sha
    CONSTRAINT unique_pr_review UNIQUE (repo_full_name, pr_number, head_sha)
);

-- Enable RLS
ALTER TABLE public.pr_reviews ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if exists and create new one
DO $$
BEGIN
    DROP POLICY IF EXISTS "Users can only access their own PR reviews" ON public.pr_reviews;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Users can only access their own PR reviews"
ON public.pr_reviews
FOR ALL
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Grants
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.pr_reviews TO authenticated, service_role;

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_pr_reviews_user_id ON public.pr_reviews(user_id);
CREATE INDEX IF NOT EXISTS idx_pr_reviews_repo ON public.pr_reviews(repo_full_name);
CREATE INDEX IF NOT EXISTS idx_pr_reviews_pr_number ON public.pr_reviews(repo_full_name, pr_number);
CREATE INDEX IF NOT EXISTS idx_pr_reviews_cache_key ON public.pr_reviews(repo_full_name, pr_number, head_sha);
CREATE INDEX IF NOT EXISTS idx_pr_reviews_created_at ON public.pr_reviews(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_pr_reviews_review_data ON public.pr_reviews USING GIN (review_data);

-- =============================================================================
-- 4. File Reviews Table (Optional - for file-level caching)
-- Stores reviews for individual files by content hash
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.file_reviews (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- File identification
    content_hash TEXT NOT NULL, -- Hash of file content for cache key
    filename TEXT NOT NULL,
    language TEXT,
    file_size INTEGER,
    
    -- Review results
    overall_score INTEGER,
    grade TEXT,
    total_issues INTEGER DEFAULT 0,
    
    -- Full review data
    review_data JSONB,
    
    -- Metadata
    model TEXT DEFAULT 'gemini-2.0-flash-exp',
    tokens_used INTEGER,
    
    -- Cache constraint
    CONSTRAINT unique_file_review UNIQUE (content_hash)
);

-- Enable RLS (public cache, but still needs authentication to access)
ALTER TABLE public.file_reviews ENABLE ROW LEVEL SECURITY;

-- Allow authenticated users to read all cached file reviews
DO $$
BEGIN
    DROP POLICY IF EXISTS "Authenticated users can read file reviews" ON public.file_reviews;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Authenticated users can read file reviews"
ON public.file_reviews
FOR SELECT
TO authenticated
USING (true);

-- Only service role can insert (backend only)
DO $$
BEGIN
    DROP POLICY IF EXISTS "Service role can manage file reviews" ON public.file_reviews;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Service role can manage file reviews"
ON public.file_reviews
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Grants
GRANT SELECT ON TABLE public.file_reviews TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.file_reviews TO service_role;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_file_reviews_content_hash ON public.file_reviews(content_hash);
CREATE INDEX IF NOT EXISTS idx_file_reviews_language ON public.file_reviews(language);

-- =============================================================================
-- 5. User Usage Tracking (for rate limiting)
-- Track daily usage per user for free tier limits
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.user_usage (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Usage counters
    code_reviews_count INTEGER DEFAULT 0,
    pr_reviews_count INTEGER DEFAULT 0,
    tokens_used INTEGER DEFAULT 0,
    
    -- Constraints
    CONSTRAINT unique_user_date UNIQUE (user_id, date)
);

-- Enable RLS
ALTER TABLE public.user_usage ENABLE ROW LEVEL SECURITY;

-- Drop existing policy if exists and create new one
DO $$
BEGIN
    DROP POLICY IF EXISTS "Users can only access their own usage" ON public.user_usage;
EXCEPTION
    WHEN undefined_object THEN NULL;
END
$$;

CREATE POLICY "Users can only access their own usage"
ON public.user_usage
FOR ALL
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

-- Grants
GRANT SELECT, INSERT, UPDATE ON TABLE public.user_usage TO authenticated, service_role;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_user_usage_user_date ON public.user_usage(user_id, date);

-- =============================================================================
-- 6. Helper Function: Increment Usage Counter
-- =============================================================================

CREATE OR REPLACE FUNCTION public.increment_usage(
    p_user_id UUID,
    p_code_reviews INTEGER DEFAULT 0,
    p_pr_reviews INTEGER DEFAULT 0,
    p_tokens INTEGER DEFAULT 0
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO public.user_usage (user_id, date, code_reviews_count, pr_reviews_count, tokens_used)
    VALUES (p_user_id, CURRENT_DATE, p_code_reviews, p_pr_reviews, p_tokens)
    ON CONFLICT (user_id, date)
    DO UPDATE SET
        code_reviews_count = user_usage.code_reviews_count + EXCLUDED.code_reviews_count,
        pr_reviews_count = user_usage.pr_reviews_count + EXCLUDED.pr_reviews_count,
        tokens_used = user_usage.tokens_used + EXCLUDED.tokens_used;
END;
$$;

-- =============================================================================
-- 7. Helper Function: Check Rate Limit
-- Returns true if user is within rate limits
-- =============================================================================

CREATE OR REPLACE FUNCTION public.check_rate_limit(
    p_user_id UUID,
    p_limit_type TEXT DEFAULT 'code_reviews', -- 'code_reviews' or 'pr_reviews'
    p_daily_limit INTEGER DEFAULT 10
)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_current_count INTEGER;
BEGIN
    SELECT 
        CASE 
            WHEN p_limit_type = 'code_reviews' THEN code_reviews_count
            WHEN p_limit_type = 'pr_reviews' THEN pr_reviews_count
            ELSE 0
        END
    INTO v_current_count
    FROM public.user_usage
    WHERE user_id = p_user_id AND date = CURRENT_DATE;
    
    -- If no record exists, user hasn't used any quota today
    IF v_current_count IS NULL THEN
        RETURN TRUE;
    END IF;
    
    RETURN v_current_count < p_daily_limit;
END;
$$;

-- =============================================================================
-- 8. Sequence Grants (for identity columns)
-- =============================================================================

DO $$
BEGIN
    IF to_regclass('public.github_connections_id_seq') IS NOT NULL THEN
        EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE public.github_connections_id_seq TO authenticated, service_role';
    END IF;
    
    IF to_regclass('public.github_repositories_id_seq') IS NOT NULL THEN
        EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE public.github_repositories_id_seq TO authenticated, service_role';
    END IF;
    
    IF to_regclass('public.pr_reviews_id_seq') IS NOT NULL THEN
        EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE public.pr_reviews_id_seq TO authenticated, service_role';
    END IF;
    
    IF to_regclass('public.file_reviews_id_seq') IS NOT NULL THEN
        EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE public.file_reviews_id_seq TO authenticated, service_role';
    END IF;
    
    IF to_regclass('public.user_usage_id_seq') IS NOT NULL THEN
        EXECUTE 'GRANT USAGE, SELECT ON SEQUENCE public.user_usage_id_seq TO authenticated, service_role';
    END IF;
END
$$;

-- =============================================================================
-- 9. Comments for Documentation
-- =============================================================================

COMMENT ON TABLE public.github_connections IS 'Stores GitHub OAuth connections for users';
COMMENT ON COLUMN public.github_connections.access_token IS 'GitHub OAuth access token - consider encrypting in production';
COMMENT ON COLUMN public.github_connections.scope IS 'OAuth scopes granted (e.g., repo, read:user)';

COMMENT ON TABLE public.github_repositories IS 'Connected GitHub repositories for monitoring';
COMMENT ON COLUMN public.github_repositories.auto_review_enabled IS 'Whether to automatically review new PRs';
COMMENT ON COLUMN public.github_repositories.webhook_id IS 'GitHub webhook ID for receiving PR events';

COMMENT ON TABLE public.pr_reviews IS 'Cached AI reviews for pull requests';
COMMENT ON COLUMN public.pr_reviews.head_sha IS 'Git commit SHA - used to invalidate cache when PR is updated';
COMMENT ON COLUMN public.pr_reviews.review_data IS 'Full structured review data as JSON';

COMMENT ON TABLE public.file_reviews IS 'Cached file-level reviews by content hash';
COMMENT ON COLUMN public.file_reviews.content_hash IS 'Hash of file content for cache deduplication';

COMMENT ON TABLE public.user_usage IS 'Daily usage tracking for rate limiting';

COMMENT ON FUNCTION public.increment_usage IS 'Increment usage counters for a user (upserts for current date)';
COMMENT ON FUNCTION public.check_rate_limit IS 'Check if user is within daily rate limits';

-- =============================================================================
-- Migration Complete!
-- =============================================================================

SELECT 'Migration complete! Tables created:' AS status;
SELECT '- github_connections' AS table_name
UNION ALL SELECT '- github_repositories'
UNION ALL SELECT '- pr_reviews'
UNION ALL SELECT '- file_reviews'
UNION ALL SELECT '- user_usage';
